#################################################################################
Sort List
    Sort a linked list in O(n log n) time using constant space complexity.

#################################################################################
Rotate List

#################################################################################
Reverse Linked List

#################################################################################
Reverse Linked List II
    Reverse a linked list from position m to n. Do it in-place and in one-pass.
    For example:
    Given 1->2->3->4->5->NULL, m = 2 and n = 4,
    return 1->4->3->2->5->NULL.
    Note:
    Given m, n satisfy the following condition:
    1 ≤ m ≤ n ≤ length of list.
Hints :


#################################################################################
Reorder List

#################################################################################
Remove Nth Node From End of List

#################################################################################
Remove Linked List Elements (Recursion)
    Remove all elements from a linked list of integers that have value val.
    Example
    Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
    Return: 1 --> 2 --> 3 --> 4 --> 5

#################################################################################
Remove Duplicates from Sorted List II
    Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.
    For example,
    Given 1->2->3->3->4->4->5, return 1->2->5.
    Given 1->1->1->2->3, return 2->3

#################################################################################
Remove Duplicates from Sorted List (Recursion)
    Given a sorted linked list, delete all duplicates such that each element appear only once.
    For example,
    Given 1->1->2, return 1->2.
    Given 1->1->2->3->3, return 1->2->3.

#################################################################################
Plus One Linked List

#################################################################################
Partition List

#################################################################################
Palindrome Linked List
    Given a singly linked list, determine if it is a palindrome.
    Follow up:
    Could you do it in O(n) time and O(1) space?
#################################################################################
Odd Even Linked List

#################################################################################
Nested List Weight Sum II

#################################################################################
Nested List Weight Sum

#################################################################################
Minimum Index Sum of Two Lists

#################################################################################
Merge k Sorted Lists

#################################################################################
Merge Two Sorted Lists

#################################################################################
Linked List Random Node

#################################################################################
Linked List Cycle
    Given a singly-linked list, implement a method to check if the list has
    cycles. The space complexity can be O(n). If there is a cycle, return true
    otherwise return false. Empty lists should be considered non-cyclic.
    Examples:
    1->2->3->4->1 ==> true
    1->2->3->4 ==> false
Hint : Slow and Fast pointer (Floyd's algorithm)

#################################################################################
Linked List Cycle II
    Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
    Note: Do not modify the linked list.
    Follow up:
    Can you solve it without using extra space?
Hint : 1 .Slow and Fast pointer (Floyd's algorithm), 
       2. What is the cycle length? 
       3. How far is the meeting point between Head and Cycle start?

#################################################################################
Intersection of Two Linked Lists

#################################################################################
Insertion Sort List
    Sort a linked list using insertion sort.
#################################################################################
Flatten Nested List Iterator

#################################################################################
Flatten Binary Tree to Linked List

#################################################################################
Delete Node in a Linked List
    Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.
    Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.

#################################################################################
Copy List with Random Pointer

#################################################################################
Convert Sorted List to Binary Search Tree

vim:tw=90:et:norl:
